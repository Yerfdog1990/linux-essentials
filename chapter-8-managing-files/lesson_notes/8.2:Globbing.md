# 8.2 Globbing

Glob characters, often referred to as **wildcards**, are symbol characters that have special meaning to the shell.

Globs are powerful because they allow you to specify **patterns** that match filenames in a directory. Instead of manipulating one file at a time, you can execute commands that affect many files at once.

For example, globbing makes it possible to:

* Manipulate all files with a specific extension
* Work with files that begin with a certain letter
* Target files with a particular filename length

---

## How Globbing Works

Unlike regular commands, glob characters are:

* **Interpreted by the shell itself**
* Processed **before** the command runs

This means the shell expands the glob pattern into matching filenames first, then passes those filenames to the command.

Because globbing happens at the shell level, glob characters can be used with **any command**.

In this section, the `echo` command is used only for demonstration purposes. It simply prints the results of the glob expansion to the screen.

---

# 8.2.1 The Asterisk `*` Character

The asterisk `*` represents:

> **Zero or more of any character**

It can match:

* No characters
* One character
* Many characters

### Example 1: Match Files That Begin With a Specific Letter

To display all files in the `/etc` directory that begin with the letter `t`:

```
sysadmin@localhost:~$ echo /etc/t*
/etc/terminfo /etc/timezone /etc/tmpfiles.d
```

### Explanation

* `t*` means:

    * Start with the letter `t`
    * Followed by zero or more characters

So this matches:

* `terminfo`
* `timezone`
* `tmpfiles.d`

---

### Example 2: Match Files That End With `.d`

The `*` can appear anywhere in the pattern.

To match files in `/etc` that end with `.d`:

```
sysadmin@localhost:~$ echo /etc/*.d
/etc/apparmor.d /etc/binfmt.d /etc/cron.d /etc/depmod.d /etc/init.d /etc/insserv.conf.d /etc/ld.so.conf.d /etc/logrotate.d /etc/modprobe.d /etc/modules-load.d /etc/pam.d /etc/profile.d /etc/rc0.d /etc/rc1.d /etc/rc2.d /etc/rc3.d /etc/rc4.d /etc/rc5.d /etc/rc6.d /etc/rcS.d /etc/rsyslog.d /etc/sudoers.d /etc/sysctl.d /etc/tmpfiles.d /etc/update-motd.d
```

### Explanation

* `*.d` means:

    * Any filename
    * That ends with `.d`

---

### Example 3: Match Files That Begin and End With Specific Patterns

To display files that:

* Begin with `r`
* End with `.conf`

```
sysadmin@localhost:~$ echo /etc/r*.conf
/etc/resolv.conf /etc/rsyslog.conf
```

### Explanation

* `r*.conf` means:

    * Starts with `r`
    * Ends with `.conf`
    * Anything can appear in between

---

# 8.2.2 The Question Mark `?` Character

The question mark `?` represents:

> **Exactly one character**

Each `?` matches:

* One character
* No more
* No less

---

### Example 1: Match Files With Exact Character Length

Suppose you want files in `/etc` that:

* Start with `t`
* Have exactly 7 characters after the `t`

```
sysadmin@localhost:~$ echo /etc/t???????
/etc/terminfo /etc/timezone
```

### Explanation

* `t???????`

    * `t` → must begin with `t`
    * `???????` → exactly 7 characters after it

So the total filename length is 8 characters.

---

### Example 2: Match Files With 20 or More Characters

Glob characters can be combined for more complex matching.

The following pattern matches files with **twenty or more characters** in their filename:

```
sysadmin@localhost:~$ echo /etc/*????????????????????
/etc/bindresvport.blacklist /etc/ca-certificates.conf
```

### Explanation

* `*` → zero or more characters
* `????????????????????` → exactly 20 characters

So this pattern ensures filenames have **at least 20 characters**.

---

### Example 3: Match Files With Three-Letter Extensions

The `*` and `?` can be used together.

To find files with **three-letter extensions**:

```
sysadmin@localhost:~$ echo /etc/*.???
/etc/issue.net /etc/locale.gen
```

### Explanation

* `*` → any filename
* `.` → literal dot
* `???` → exactly three characters after the dot

This matches files like:

* `issue.net`
* `locale.gen`

---

# 8.2.3 Bracket `[ ]` Characters

The bracket `[ ]` characters are used to match **a single character** by representing a **set or range of possible match characters**.

Unlike the `*` (zero or more characters) and `?` (exactly one character), brackets match:

> **Exactly one character from the specified set or range**

---

## Matching Specific Characters

The pattern `/etc/[gu]*` matches any file that:

* Begins with either `g` **or** `u`
* Followed by zero or more additional characters

```id="g7k29s"
sysadmin@localhost:~$ echo /etc/[gu]*
/etc/gai.conf /etc/groff /etc/group /etc/group- /etc/gshadow /etc/gshadow- /etc/gss /etc/ucf.conf /etc/udev /etc/ufw /etc/update-motd.d /etc/updatedb.conf
```

### Explanation

* `[gu]` → first character must be either `g` or `u`
* `*` → zero or more characters after that

---

## Matching a Range of Characters

Brackets can also represent a **range** using a hyphen `-`.

The pattern `/etc/[a-d]*` matches files that begin with any letter:

* From `a` through `d`
* Including both `a` and `d`

```id="p3n82k"
sysadmin@localhost:~$ echo /etc/[a-d]*
/etc/adduser.conf /etc/alternatives /etc/apparmor /etc/apparmor.d /etc/apt /etc/bash.bashrc /etc/bind /etc/bindresvport.blacklist /etc/binfmt.d /etc/ca-certificates /etc/ca-certificates.conf /etc/calendar /etc/console-setup /etc/cron.d /etc/cron.daily /etc/cron.hourly /etc/cron.monthly /etc/cron.weekly /etc/crontab /etc/dbus-1 /etc/debconf.conf /etc/debian_version /etc/default /etc/deluser.conf /etc/depmod.d /etc/dhcp /etc/dpkg
```

### Explanation

* `[a-d]` → any single character from `a` to `d`
* `*` → zero or more characters afterward

---

## Matching Files Containing Numbers

The pattern `/etc/*[0-9]*` matches any file that contains **at least one number**:

```id="u9q17v"
sysadmin@localhost:~$ echo /etc/*[0-9]*
/etc/X11 /etc/dbus-1 /etc/iproute2 /etc/mke2fs.conf /etc/python3 /etc/python3.6 /etc/rc0.d /etc/rc1.d /etc/rc2.d /etc/rc3.d /etc/rc4.d /etc/rc5.d /etc/rc6.d
```

### Explanation

* `*` → zero or more characters
* `[0-9]` → any single digit
* `*` → zero or more characters after the digit

This ensures the filename contains **at least one numeric character**.

---

## ASCII Ordering and Ranges

Character ranges are based on the **ASCII text table**.

ASCII defines a standard character order. Ranges must follow this order correctly.

If an invalid range is provided, no matches will occur:

```id="z4r8lx"
sysadmin@localhost:~$ echo /etc/*[9-0]*
/etc/*[9-0]*
```

Since `9-0` is not a valid ASCII range (it is reversed), nothing matches and the pattern is printed literally.

---

### Viewing the ASCII Table

The ASCII text table can be viewed in the virtual machines by executing:

```bash
ascii
```

This command displays the ASCII character table and its ordering.

---

# 8.2.4 Exclamation Point `!` Character

The exclamation point `!` is used **inside square brackets** to negate a range.

It means:

> Match any single character **not** in the specified set.

---

### Example: Match Files Not Beginning With Certain Letters

The pattern `/etc/[!a-t]*` matches any file that:

* Does **not** begin with letters `a` through `t`

```id="k8m29w"
sysadmin@localhost:~$ echo /etc/[!a-t]*
/etc/X11 /etc/ucf.conf /etc/udev /etc/ufw /etc/update-motd.d /etc/updatedb.conf /etc/vim /etc/vtrgb /etc/wgetrc /etc/xdg
```

### Explanation

* `[!a-t]` → first character cannot be between `a` and `t`
* `*` → zero or more characters afterward

This excludes all filenames starting with letters `a` through `t`.

---

# 8.2.5 Listing With Globs

Normally, the `ls` command is used to list files in a directory. So using `echo` for demonstrations may seem unusual.

However, there is an important reason for this choice.

---

## Important Concept: The Shell Expands Globs

Remember:

> It is the **shell**, not the `echo` or `ls` command, that expands the glob pattern.

When you run:

```bash
echo /etc/a*
```

The shell first replaces `/etc/a*` with all matching filenames. Then it runs:

```bash
echo /etc/adduser.conf /etc/alternatives /etc/apparmor /etc/apparmor.d /etc/apt
```

---

## What Happens With `ls /etc/a*`

If you run:

```bash
ls /etc/a*
```

The shell actually runs:

```bash
ls /etc/adduser.conf /etc/alternatives /etc/apparmor /etc/apparmor.d /etc/apt
```

When `ls` sees multiple arguments, it performs a listing on **each item separately**.

This is equivalent to running:

```bash
ls /etc/adduser.conf
ls /etc/alternatives
ls /etc/apparmor
ls /etc/apparmor.d
ls /etc/apt
```

---

## Listing a Single File

When `ls` is given a file:

```id="b6f0qp"
sysadmin@localhost:~$ ls /etc/adduser.conf
/etc/adduser.conf
```

It prints just the filename.

With the `-l` option:

```id="n4v1rt"
sysadmin@localhost:~$ ls -l /etc/adduser.conf
-rw-r--r-- 1 root root 3028 May 26  2018 /etc/adduser.conf
```

It shows detailed file information.

---

## Listing a Directory

If `ls` is given a directory:

```id="r3w9km"
sysadmin@localhost:~$ ls /etc/apparmor
init  parser.conf  subdomain.conf
```

Instead of printing `/etc/apparmor`, it displays the **contents of that directory**.

---

## Why This Causes Confusion With Globs

Consider:

```id="m8x2ld"
sysadmin@localhost:~$ ls /etc/ap*
/etc/apparmor:
init  parser.conf  subdomain.conf

/etc/apparmor.d:
abstractions  disable  local  tunables  usr.sbin.named
cache  force-complain  sbin.dhclient  usr.bin.man  usr.sbin.rsyslogd

/etc/apt:
apt.conf.d  preferences.d  sources.list  sources.list.d  trusted.gpg.d
```

Here:

* For regular files → `ls` prints the filename.
* For directories → `ls` prints their **contents**.

This creates confusing output.

---

### Even More Confusing Example

```id="x9t5qw"
sysadmin@localhost:~$ ls /etc/x*
autostart  systemd  user-dirs.conf  user-dirs.defaults
```

It may seem incorrect, but what happened is:

* The only match for `/etc/x*` was `/etc/xdg`
* `ls` then displayed the contents of `/etc/xdg`

It did **not** list multiple files starting with `x`.

---

# The Solution: Use `-d` With Globs

To avoid this confusion, always use the `-d` option with glob patterns.

The `-d` option tells `ls`:

> Display directory names themselves, not their contents.

Example:

```id="w2z8jn"
sysadmin@localhost:~$ ls -d /etc/x*
/etc/xdg
```

Now the output clearly shows the directory name instead of its contents.

---

# Key Takeaways

### Asterisk `*`

* Matches **zero or more characters**
* Can appear anywhere in a pattern
* Commonly used to match:

    * All files of a type (`*.txt`)
    * Files starting with a letter (`a*`)
    * Files ending with a suffix (`*.conf`)

### Question Mark `?`

* Matches **exactly one character**
* Used to control filename length precisely

### Important Concept

* Globbing is handled by the **shell**
* It occurs **before** the command runs
* Works with **any command**, not just `echo`

### Brackets `[ ]`

* Match exactly one character
* Can specify:

    * A set → `[abc]`
    * A range → `[a-z]`
    * Numbers → `[0-9]`

### Negation `[! ]`

* Matches one character **not** in the specified range

### ASCII Rules

* Ranges follow ASCII ordering
* Invalid ranges produce no matches
* View ASCII using:

  ```bash
  ascii
  ```

### Using `ls` With Globs

* The shell expands glob patterns first
* `ls` treats files and directories differently
* Always use:

  ```bash
  ls -d pattern
  ```

  to avoid confusing output

---

Globbing provides powerful pattern matching capabilities in Linux. Mastering `*`, `?`, `[ ]`, and `[! ]` allows you to precisely control how multiple files are selected and manipulated from the command line.

---