## 2.1.1 Decision Points

When specifying or designing a computer system, several key **decision points** must be considered. These decisions affect performance, cost, usability, and long-term sustainability.

---

# 1. Role

The first and most important decision is determining the **machine’s role**.

### A. Desktop System

Choose a desktop system if:

* A user will sit at the console
* The machine will run productivity applications
* The primary activities are web browsing, office work, or content creation

Desktop systems:

* Primarily run a **Graphical User Interface (GUI)**
* Are designed for ease of use
* Focus on user interaction and visual tools

---

### B. Server System

Choose a server system if:

* The machine will be accessed remotely
* It will provide services to multiple users
* It will serve applications, files, or network resources

Servers typically:

* Sit in racks in data centers
* Share keyboard and monitor access with many systems
* Use console access mainly for configuration and troubleshooting
* Run primarily in a **Command Line Interface (CLI)** environment

Running as a CLI:

* Frees up system resources
* Improves performance
* Focuses computing power on serving clients

A **client** is any user or system that accesses resources remotely.

---

# 2. Function

Once the role is defined, the next step is determining the machine’s **function**.

Key questions include:

* What software must it run?
* What specific tasks must it perform?
* Will there be hundreds or thousands of identical systems?
* What is the technical skill level of the managing team?

### Examples:

* A web server must run web server software.
* A database server must handle high disk I/O.
* A scientific computing system may require parallel processing.
* A development workstation may need advanced tools and compilers.

The function determines:

* Hardware requirements
* Operating system selection
* Management complexity
* Scalability needs

---

# 3. Life Cycle

Every operating system and application has a **life cycle**.

### A. Release Cycle

Software is released periodically. This is called the **release cycle**.

Vendors:

* Introduce new versions
* Add features
* Patch bugs
* Improve security

---

### B. Maintenance Cycle

Older versions are supported only for a limited time.

After that:

* No updates
* No security patches
* No vendor support

This period is called the **maintenance cycle** or **life cycle**.

---

### Enterprise Considerations

In enterprise environments:

* Major upgrades are expensive
* Downtime affects productivity
* Reconfiguration takes time
* Testing is required

Often:

* Hardware is replaced instead of upgraded
* Increased performance justifies replacement cost

The real cost of upgrades is often:

* Staff time
* Configuration effort
* Application testing
* Risk management

Organizations seek to maximize return on investment in both:

* Human capital
* Financial capital

---

# 4. Virtualization and Cloud Solutions

Modern data centers reduce upgrade complexity through **virtualization**.

### Virtualization

Virtualization allows:

* One physical machine to host many virtual machines
* Reduced power consumption
* Reduced physical space
* Automated deployment

With scripting tools:

* Virtual machines can be created automatically
* Configurations can be deployed rapidly
* Systems can be removed without manual setup

A human still:

* Writes scripts
* Monitors systems
* Maintains security

---

### Cloud Services

Cloud providers reduce the need for physical hardware upgrades.

Examples include:

* **Amazon Web Services**
* **Rackspace**
* **Microsoft Azure**

Cloud services allow organizations to:

* Scale up or down
* Pay only for what they use
* Reduce capital expenditure
* Outsource infrastructure management

Desktop administrators also benefit from automation tools that:

* Deploy updates
* Minimize user interruption
* Standardize configurations

---

# 5. Stability

Software releases are categorized based on maturity.

### A. Beta Software

* Contains new features
* May not be fully tested
* Higher risk of bugs

Often used:

* During development
* In testing environments
* When early access to features is needed

---

### B. Stable Software

* Fully tested
* Production-ready
* Lower risk

Production servers usually:

* Run stable releases
* Avoid unnecessary risk

Exception:

* When required features exist only in beta

---

### Open Source vs Proprietary Development

Open source software:

* Released early for peer review
* Rapidly tested in real-world environments
* Encourages community contributions

Proprietary software:

* Developed privately
* Released publicly later
* Often reaches beta stage close to final release

---

# 6. Compatibility

Another major decision factor is **backward compatibility**.

Backward compatibility means:

A newer operating system can run software designed for older versions.

This is important when:

* Application upgrades are too expensive
* Software is no longer supported
* Legacy systems must remain operational

---

### Open Source Practice

Open source projects often:

* Maintain backward compatibility
* Use versioned libraries
* Keep older functions available

Libraries are versioned when:

* Significant changes occur
* New features are added
* Older functionality must still work

Breaking compatibility is usually:

* A last resort

---

# 7. Cost

Cost is always a critical factor.

Consider:

* Licensing fees
* Hardware costs
* Maintenance expenses
* Staff training
* Future scalability

Some operating systems require annual licensing fees, such as:

* **Microsoft Windows**

Open source systems often:

* Reduce licensing costs
* Increase flexibility
* Require skilled administrators

---

### Modern Cost Strategies

Virtualization and outsourced services:

* Reduce upfront investment
* Eliminate overbuilding infrastructure
* Provide flexible scaling

Organizations can:

* Pay only for resources used
* Outsource expertise when needed
* Focus internal teams on strategic tasks

---

# 8. Interface

The interface determines how users interact with the system.

### Historical Evolution

1. Switches and plugboards
2. Punch cards
3. Text-based terminals (similar to Linux CLI)
4. Graphical User Interfaces (GUI)

The modern GUI was:

* Pioneered at **Xerox PARC**
* Popularized in the 1980s by Apple Computer

---

### GUI vs CLI Today

Most modern operating systems offer:

* GUI for ease of use
* CLI for advanced administration

Consumer systems like:

* **Microsoft Windows**
* **macOS**

Are designed to shield typical users from the command line.

However:

* Servers heavily rely on CLI
* System administrators depend on command-line tools for efficiency

---

# Summary of Decision Points

When selecting or specifying a computer system, consider:

1. **Role** – Desktop or server
2. **Function** – What tasks must it perform?
3. **Life Cycle** – How long will it be supported?
4. **Stability** – Beta or stable release?
5. **Compatibility** – Will legacy software work?
6. **Cost** – Licensing, hardware, and maintenance
7. **Interface** – GUI, CLI, or both?

Careful evaluation of these factors ensures that the selected system meets current needs while remaining adaptable, cost-effective, and sustainable over time.

---