# 5.6 Quoting

Quotation marks are extremely important in Linux administration and programming. They tell the shell how to treat the text inside them — either:

* Ignore special meanings, or
* Treat the text differently than normal

In the Bash shell, **three types of quoting mechanisms** have special meaning:

1. **Double quotes** `"`
2. **Single quotes** `'`
3. **Back quotes (backticks)** `` ` ``

Each type changes how the shell interprets special characters (metacharacters).

---

## Why Quoting Is Important

The Bash shell normally interprets special characters before running a command. These include:

* Variable indicators (`$`)
* Wildcards (glob characters)
* Command substitution symbols
* Other shell metacharacters

Quoting allows you to control this interpretation.

---

# 5.6.1 Double Quotes `" "`

Double quotes prevent the shell from interpreting **some** special characters, including:

* Glob characters (wildcards)
* Certain metacharacters

However, double quotes **still allow**:

* Variable substitution (`$VARIABLE`)
* Command substitution (`` `command` ``)
* Some other shell expansions

---

## Glob Characters (Wildcards)

Glob characters are special symbols interpreted by the shell before a command runs.

Common glob characters include:

* `*` (asterisk)
* `?` (question mark)
* `[ ]` (brackets)

Normally, the shell expands these into matching filenames.

Inside double quotes, they are treated as literal characters.

### Example:

```
sysadmin@localhost:~$ echo "The glob characters are *, ? and [ ]"      
The glob characters are *, ? and [ ]
```

Here:

* The `*`, `?`, and `[ ]` are displayed literally.
* The shell does not attempt to match filenames.

---

## Variable Substitution Still Works in Double Quotes

Double quotes allow variables to be interpreted.

Example:

```
sysadmin@localhost:~$ echo "The path is $PATH"                          
The path is /usr/bin/custom:/home/sysadmin/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games
```

Here:

* `$PATH` is replaced with its value.
* This is called **variable substitution**.

---

## Summary of Double Quotes

Inside double quotes:

1. [ ] ✔ Globs are treated literally
2. [ ] ✔ Some metacharacters are ignored
3. [ ] ✔ Variables still expand
4. [ ] ✔ Command substitution still works

---

# 5.6.2 Single Quotes `' '`

Single quotes prevent the shell from interpreting **any** special characters.

This includes:

* Globs
* Variables
* Command substitution
* All other metacharacters

Everything inside single quotes is treated as **literal text**.

---

## Example: Variable Interpretation Without Quotes

```
sysadmin@localhost:~$ echo The car costs $100                           
The car costs 00
```

Explanation:

* `$100` is interpreted as a variable.
* Since no such variable exists, the shell removes `$1`.
* Only `00` remains.

---

## Example: Using Single Quotes

```
sysadmin@localhost:~$ echo 'The car costs $100'                        
The car costs $100
```

Here:

* `$100` is not treated as a variable.
* The dollar sign is printed literally.

---

## Summary of Single Quotes

Inside single quotes:

1. [ ] ✔ Nothing is interpreted
2. [ ] ✔ Everything is literal
3. [ ] ✔ Variables do NOT expand
4. [ ] ✔ Command substitution does NOT occur

Single quotes provide the **strongest form of quoting**.

---

# 5.6.3 Backslash Character `\`

The backslash (`\`) is used to escape a **single character**.

It tells the shell:

> “Treat the next character literally.”

This is useful when you want to prevent interpretation of only one character rather than quoting an entire string.

---

## Example Scenario

Message:

```
The service costs $1 and the path is $PATH
```

---

## Using Double Quotes

```
sysadmin@localhost:~$ echo "The service costs $1 and the path is $PATH"

The service costs  and the path is /usr/bin/custom:/home/sysadmin/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games 
```

Explanation:

* `$1` is treated as a variable (empty here).
* `$PATH` expands to its value.

---

## Using Single Quotes

```
sysadmin@localhost:~$ echo 'The service costs $1 and the path is $PATH' 
The service costs $1 and the path is $PATH 
```

Explanation:

* Neither `$1` nor `$PATH` are expanded.
* Everything is literal.

---

## Using Backslash to Escape Only One Variable

What if you want:

* `$1` to be literal
* `$PATH` to expand

Use a backslash:

```
sysadmin@localhost:~$ echo The service costs \$1 and the path is $PATH
The service costs $1 and the path is /usr/bin/custom:/home/sysadmin/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games
```

Explanation:

* `\$1` prevents `$1` from being interpreted.
* `$PATH` still expands normally.

---

## Summary of Backslash

The backslash:

1. [ ] ✔ Escapes a single character
2. [ ] ✔ Prevents interpretation of that character
3. [ ] ✔ Allows selective control within a command

---

# 5.6.4 Backquotes (Backticks) `` ` ` ``

Backquotes are used for **command substitution**.

Command substitution means:

> Execute a command and use its output inside another command.

This is a powerful feature of the shell.

---

## Example: The `date` Command

```
sysadmin@localhost:~$ date                                           
Mon Nov  4 03:35:50 UTC 2018
```

The `date` command displays the current date and time.

---

## Example Without Backquotes

```
sysadmin@localhost:~$ echo Today is date                               
Today is date
```

Here:

* The word `date` is treated as plain text.
* It is not executed.

---

## Example With Backquotes

```
sysadmin@localhost:~$ echo Today is `date`                         
Today is Mon Nov 4 03:40:04 UTC 2018
```

Explanation:

1. The shell executes `date`.
2. It captures the output.
3. It substitutes the output into the `echo` command.
4. `echo` prints the result.

This process is called **command substitution**.

---

# Overall Summary of Quoting in Bash

| Method               | What It Prevents                    | What Still Works                   |
| -------------------- | ----------------------------------- | ---------------------------------- |
| Double Quotes `" "`  | Some metacharacters, glob expansion | Variables and command substitution |
| Single Quotes `' '`  | All interpretation                  | Nothing is expanded                |
| Backslash `\`        | Escapes one character               | Everything else works normally     |
| Backquotes `` ` ` `` | Executes enclosed command           | Substitutes output                 |

---

# Key Takeaways

* The shell normally interprets special characters before executing commands.
* Quoting controls how that interpretation occurs.
* Double quotes provide partial protection.
* Single quotes provide complete literal protection.
* Backslash escapes a single character.
* Backquotes allow command substitution.

Understanding quoting is essential for:

* Writing accurate commands
* Avoiding unexpected variable expansion
* Preventing globbing errors
* Writing scripts correctly
* Combining commands effectively

Quoting gives you precise control over how Bash processes your commands — a critical skill for Linux administration.

---